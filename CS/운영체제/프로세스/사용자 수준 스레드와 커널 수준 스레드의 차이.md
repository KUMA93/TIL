# **사용자 수준 스레드와 커널 수준 스레드**

* 사용자 수준 스레드와 커널 수준 스레드는 `생성 주체`가 누구냐에 따라 구분된다.
* 사용자가 라이브러리를 통해 만들고 관리하는 스레드는 `사용자 수준 스레드`
* OS의 커널이 만들고 관리하는 스레드는 `커널 수준 스레드`


## **사용자 수준 스레드**
![사용자 수준 스레드](../img/사용자%20수준%20스레드.png)
* 사용자가 스레드 관련 라이브러리로 구현해 사용하는 스레드를 사용자 수준 스레드라고 한다.
* 스레드와 관련된 모든 행위를 사용자 영역에서 하기 때문에 커널은 사용자 수준 스레드의 존재를 알지 못하고 스레드 교환에 개입하지 않는다.
* `사용자 수준 스레드 N개`가 `커널 수준 스레드 1개`에 매핑되므로 다대일 스레드 매핑이라고 한다.

### **장점**
* `커널에 독립적`으로 스케쥴링을 할 수 있어 `모든 운영체제에 적용`할 수 있다.(이식성이 높다.)
* 스케쥴링이나 동기화를 위해 커널을 호출하지 않으므로, `커널 영역으로 전환하는 오버헤드가 줄어든다`.
* 커널이 아닌 스레드 라이브러리에서 스레드 스케쥴링을 제어하므로, `유연한 스케쥴링이 가능`하다.

### **단점**
* `하나의 프로세스로부터 할당`된 여러개의 스레드들 중, `한 스레드가 대기 상태`가 되면, `모든 스레드들을 실행시킬 수 없게 된다.`
* 커널이 스레드 관리에 개입하지 않으므로, `스레드 간 보호에 커널의 보호 방법을 사용할 수 없다.` 라이브러리 수준의 보호방법까지만 사용 가능하다.

## **커널 수준 스레드**
![커널 수준 스레드](../img/커널%20수준%20스레드.png)
* `커널이 스레드와 관련된 모든 작업을 관리`하는 방식이다.
* 사용자 수준 스레드와 커널 수준 스레드가 `1대1로 매핑`된다.
* 커널이 직접 스케쥴링하고 실행하기 때문에 `커널의 관리 지원`을 많이 받을 수 있지만, 그만큼 `오버헤드가 늘어난다`.
* 커널이 각 스레드들을 개별적으로 관리할 수 있으므로, `하나의 프로세스에서 할당`된 여러개의 스레드들 중 `한 스레드가 대기상태`가 되더라도 `다른 스레드들은 실행가능`하다.


## References
* [taehee-kim-dev velog](https://velog.io/@taehee-kim-dev/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%A4%80-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BB%A4%EB%84%90-%EC%88%98%EC%A4%80-%EC%8A%A4%EB%A0%88%EB%93%9C)
* [Hello Inyong](https://helloinyong.tistory.com/293)