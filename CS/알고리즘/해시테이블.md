# 해시 테이블 (Hash Table)
### 해시 테이블이란?
- key값과 value값 쌍으로 데이터를 저장하는 자료구조
- 해시 테이블은 각각의 key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다.
- 실제로 데이터가 저장되는 장소를 슬롯 혹은 버킷이라고 한다.
  
### 해시 함수란?
- 임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환시켜주는 함수
- 위변조 여부를 판별하고 무결성을 검증하는 데 사용한다.
  
```java
import java.util.LinkedList;
class hashTable {
	final static int M = 5381;
	
	class Node {
		String key;
		
		String val;
		public Node(String key, String val) {
			super();
			this.key = key;
			this.val = val;
		}
		
		String getVal() {
			return val;
		}
		
		void setVal(String val) {
			this.val = val;
		}
	}
	
	LinkedList<Node>[] data;
	
	hashTable(int size) {
		this.data = new LinkedList[size];
	}
	
	int hashfyInput(String inp) {
		int size = inp.length();
		int hashcode = 0;
		for (int i = 0; i < size; i++) {
			hashcode += ((hashcode*M) + inp.charAt(i)) % data.length;
		}
		hashcode %= data.length;
		return hashcode;
	}
	
	
	Node searchKey(LinkedList<Node> list, String key) {
		if(list == null) {
			return null;
		}
		
		for(Node node : list) {
			if (node.key.equals(key)) return node;
		}
		
		return null;
	}
	
	void put(String key, String val) {
		// 해시 코드
		int hashcode = hashfyInput(key);
		
		System.out.println(key + ", hashcode(" + hashcode + ")");
		
		LinkedList<Node> list = data[hashcode];
		
		if(list == null) {
			list = new LinkedList<Node>();
			data[hashcode] = list;
		}
		
		Node node = searchKey(list, key);
		
		if(node == null) {
			list.addLast(new Node(key, val));
		}else {
			node.setVal(val);
		}
	}
	
	String get(String key) {
		int hashcode = hashfyInput(key);
		LinkedList<Node> list = data[hashcode];
		
		Node node = searchKey(list, key);
		
		return node == null? "Not found": node.getVal();
	}
}
public class HashTableTest {
	public static void main(String[] args) {
		hashTable h = new hashTable(100);
		
		h.put("choi", "moosik");
		h.put("choi", "kyuheon");
		h.put("ahn", "ujin");
		h.put("um", "junsung");
		
		System.out.println(h.get("choi"));
		System.out.println(h.get("ahn"));
		System.out.println(h.get("um"));
	}
}
```
  
### 시간복잡도
- Insertion → 해시코드 해시함수연산 + 해시코드 값을 키값으로 갖는 저장소에 값 저장 = `O(1)`
- Deletion → 해시코드 해시함수연산 + 해시코드 값을 키값으로 갖는 저장소에 저장된 값 삭제 = `O(1)`
- Search → 해시코드 해시함수 연산 + 해시코드 값을 키값으로 갖는 저장소에 저장된 값 조회 = `O(1)`
    - but, `해시충돌이 일어난다면 O(n)까지 늘어날 수 있다`.
  
### 해시 충돌
- `무한한 값 (key) 를 유한한 값 (HashCode) 로 표현`하면서 `서로 다른 두 개 이상의 유한한 값이 동일한 출력`을 갖게 되는 현상
- n+1 마리의 비둘기가 n개의 비둘기 집에 들어간다면 적어도 1개 이상의 비둘기 집에는 2마리 이상의 비둘기가 있을 수 밖에 없는 비둘기집의 원리이다.
  
### 해결 방법 - Chaining
- 해시 충돌이 일어나는 경우 기존 저장소에 해당 키값에 저장되어 있던 값과 저장하려는 값을 연결시키는 기법이다.
- 장점
    - 한정된 `저장소(Bucket)을 효율적으로 사용`할 수 있다.
    - 해시 함수를 선택하는 중요성이 상대적으로 적다.
    - 미리 공간을 확보해둘 필요가 없으므로 `상대적으로 적은 메모리를 사용`한다.
- 단점
    - 한 Hash에 자료들이 계속 연결된다면(쏠림 현상) 검색 효율이 낮아진다.
    - 외부 저장 공간을 사용한다.
    - 외부 저장 공간 작업을 추가로 해야 한다.