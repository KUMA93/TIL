# 문자열
## 1013 Contact
* 패턴을 변수화 해서 대조하는 방법-> 실패, 조건에도 부합하지 않음
* deque를 이용해서 문자열 요소 하나하나 검사하는 방법-> 하나의 인덱스를 기준으로 잡고 하다보니 조건이 너무 복잡해져서 실패
* 100+1+, 01 패턴을 제거한다는 개념으로 접근 해야할 것 같아서 처음엔 다음과 같은 식으로 코드를 짰다. -> 100을 하나의 패턴으로 받아들인다기보다 무식하게 연속된 문자열 '100'을 만나면 모조리 A로 치환하는 형태라서 예외가 발생
  ```python
  S=S.replace('100', 'A')
  def findP():
    idx=S.index('A')
    rt idx
  while S:
      now=findP
      if S[now]=='A':
        S=list(S)
        del S[now]
        S=''.join(S)
        while len(S)>1 and S[now+1]=='0':
            S=S[1:]
            ...
  ```
* 구글링을 하다가 문자열에서 사용할 수 있는 startswith()함수를 알게 되었다. 이 함수를 이용해서 '100' 으로 시작되는 경우와 '01'로 시작되는 경우를 나눠 100+1+ 에 해당하는 문자열을 삭제, '01'과 일치하는 경우를 모두 삭제해서 남는 문자열이 있는 경우 'NO' 가 출력되게 하였다.
* 100+1+패턴 제거부
  ```python
  if S.startswith('100'): # 문자열이 100으로 시작하면
      S=S[3:] # 100 제거
      while S and S.startswith('0'): # 이후 0 추가 등장
          S=S[1:] # 0 추가로 제거
      if not S: # 0만 등장하다 문자열이 끝났으니 NO
          res=False
          break
      S=S[1:] # 1이 등장, 제거
      while S and S.startswith('1'): # 이후 1 추가 등장
          if len(S)>=3 and S[1]=='0' and S[2]=='0': # '100'의 패턴인 경우에 삭제하지 않음
              break
          else: # 아닌 경우 추가되는 1 제거
              S=S[1:]
  ```
* 01패턴 제거부
  ```python
  elif S.startswith('01'): # 문자열이 01로 시작하면
      S=S[2:] # 01 패턴 제거
  ```
* 패턴에 맞지 않는 문자열이 남은 경우
  ```python
  else:
      res=False
      break
  ```
## 1769 3의 배수
* 큰 자연수 x를 리스트 x에 한 자리씩 int형으로 저장
* 리스트 x의 길이가 1인 것으로 자연수 x가 한 자리가 되었는 지 판별했다.
  ```python
  if len(x)==1:
    x=x[0]
    break
  ``` 
* 위의 경우에서 벗어나 합이 한 자리가 아닌 경우 sum()함수를 이용해 각 자리 전체 합을 x에 저장해주고 다시 리스트형태로 저장해주고 횟수를 저장하는 cnt의 값 1증가시킨다.
  ```python
  else:
    x=sum(x)
    x=list(map(int, str(x)))
    cnt+=1
  ```

## 9996 한국이 그리울 땐 서버에 접속하지
* 처음엔 패턴이 *을 기준으로 한글자씩만 주어지는 줄 알고 틀림. 자세히 읽어보니 그런 조건은 없음
* 패턴을 split('*')을 통해 좌측부, 우측부로 나눠서 입력받음
    ```python
    ptlt, ptrt=map(str, input().split('*'))
    ```
* 슬라이싱을 통해 입력받은 각 케이스별 문자열 좌측과 우측을 패턴과 비교함
    ```python
    if tmp[:len(ptlt)]==ptlt and tmp[len(tmp)-len(ptrt):]==ptrt:
    ```
* 틀렸습니다가 떠서 뭐가 문젠지 고민해본 결과 다음과 같은 경우 예외 발생
    ```
    ptlt=aaa ptrt=aab
    str=aaab
    ```
    그래서 조건을 추가함
    ```python
    if len(tmp)>=len(ptlt)+len(ptrt):
    ```
* 그래도 틀렸습니다가 떠서 저번주에 strip() 안해줘서 틀린 기억이 났음. 이 문제의 경우는 줄바꿈이 문제가 된걸로 보임.

## 11478 서로 다른 부분 문자열의 개수
* 예전에 풀어놓은 문제
* 파싱을 이용해 모든 부분 문자열을 구하고 중복을 set 자료형으로 제거하고 길이를 출력하는 식으로 해결, 파이썬이라서 간단하게 되는 것 같다
  ```python
  arr=set()
  for i in range(len(S)):
      for j in range(i, len(S)):
        arr.add(S[i:j+1])
  ```

## 14425 문자열 집합
* 예전에 풀어놓은 문제, 이 문제때문에 딕셔너리 자료형에 대해 공부한 기억이 있다.
* n만큼 입력 받은 문자열을 딕셔너리의 key 값으로 하고 해당 value는 True로 저장했다.
* 다음 m만큼 입력 받은 문자열을 별다른 저장과정 없이 딕셔너리에 존재하는지 검사-> O(n)
  ```python
  S=dict()
  for i in range(n):
    S[input()]=True
  ```
* 응답속도가 수직상승하긴 하지만 그냥 문자열 하나하나 in함수로 검사해도 통과가 되긴 한다.
