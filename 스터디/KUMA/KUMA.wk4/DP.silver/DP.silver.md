# DP silver

## 1010 다리놓기
* 기본 골자는 다리끼리 겹쳐질 수 없으니 강 서쪽과 동쪽 사이트들 1대1로 연결하라는 건데 지금와서 보니 dp로 풀어도 쉬울것 같다.
* 예전에 단계별 풀기에서 풀었는데 dp가 아니고 `조합공식`으로 풀어놨다. -직접 팩토리얼을 돌려서 그 가지수만 세는 것이기 때문에 이것도 메모리와 응답시간이 매우 작게 나오긴 했다.
  ```python
  def factorial(x):
      res=1
      while x:
          res*=x
          x-=1
      return res
  for i in range(t):
      n, m=map(int, input().split())
      res=factorial(m)//(factorial(n)*factorial(m-n))
      print(res)
  ```
* `dp`의 경우는 `동쪽 사이트는 n으로 고정하고 서쪽 사이트 개수를 n부터 m까지의 값을 바로 이전 값에서 처리`를 해서 구하는 식으로 구현했다.
  ```
  n일 때,
  dp[m] => mCn => m!//n!(m-n)! 
  dp[m+1] => m+1Cn => (m+1)!//n!(m-n)! => mCn * m+1 // ((m+1)-n) 
  ```
* dp 코드 - 응답시간이 미세하게 더 빠르고 m의 값마다의 정보를 다 가지고 있다는 점에서 더 유연하다. 
  ```python
  n, m=map(int, input().split())
  dp=[0]*(m+1) # m에 따른 최대 가짓수
  dp[n]=1
  for i in range(n+1, m+1):
      dp[i]=dp[i-1]*i//(i-n)
  print(dp[-1])  
  ```
## 2193 이친수
* 문제에서 주어진 두가지 규칙은 `이친수의 첫자리 둘째자리를 '10'으로 고정`시킨다.
* 규칙성을 살펴보면 i번째 이친수들은 `0으로 끝난 i-1번째 이친수들이 (0,1)두갈래`로 뻗고 `1로 끝난 i-1번째 이친수들은 (0)한갈래`로만 뻗는다고 보인다. 
* 즉, `0으로 끝나는 i번째 이친수`는 `0으로 끝나는 i-1번째`, `1로 끝나는 i-1번째` 모두에서 파생되어 나오므로 `i-1번째 이친수 개수와 같다`.
* `1로 끝나는 i번째 이친수`는 `0으로 끝나는 i-1번째 이친수`에서만 파생되어 나온다.  
  그런데 이는 바로 `위의 규칙성에 따라 i-2번째 이친수 개수와 같아`지므로 점화식이 다음과 같이 작성 가능해진다. 
  ```
  1 1
  2 10
  3 100 / 101
  4 1000 1010 / 1001
  5 10000 10010 10100 / 10001 10101 
  dp[i]=dp[i-1]+dp[i-2]
  ```
* n의 범위가 1 ≤ N ≤ 90 에 따라 조건문을 넣어 dp[1], dp[2]는 직접 지정해준다.
  ```python
  n=int(input())
  dp=[0]*(n+1)
  dp[1]=1
  if n>1:
      dp[2]=1
  ```
* 점화식을 작성해주고 목표로 하는 이친수의 개수를 출력한다.
  ```python  
  for i in range(3, n+1):
    dp[i]=dp[i-2]+dp[i-1]
  print(dp[-1])
  ```

## 10844 쉬운 계단 수
* 단계별 풀어보기에서 풀었는데 규칙성을 알아보면 두 가지이다.
  1. `첫 자리에 0이 올수 없다`
  2. `n번째 자리에 9`가 오려면 `바로 전 자리(n-1)가 8`이어야 한다
* 위에 대한 규칙을 적용하여 각 자리수를 갖는 숫자의 개수를 표시하는 dp를 작성하면 다음과 같다.
  ```python
  *dp
  (0) 1 2 3  4 *5 6 7 8 9
   0  1 2 3 *4  5 6 7 8 9
   0  1 2 3  4 *5 6 7 8 9
  .
  .
  .
  인접한 자리의 숫자끼리는 대각선 우측 혹은 좌측이여야 한다.
  ---------------------------------------------------------
  dp=[[0]*10 for _ in range(n+1)]
  dp[0][1:10]=[1]*9 # 첫 자리에 0이 올수 없다
  for i in range(1, n+1): # 첫 자리는 이미 0빼고 1로 초기화 
      for j in range(10): # 해당 자리수의 숫자 카운팅
          if 1<=j<=8:
              dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]
          elif j==0:
              dp[i][j]=dp[i-1][j+1]
          else: #j==9
              dp[i][j]=dp[i-1][j-1]
  print(sum(dp[n-1])%1000000000)
  ``` 

## 11052 카드 구매하기
* 카드팩의 종류는 `1개부터 N개`까지 `연속적으로 존재`한다
* `dp[i]를 카드를 i개 사려할 때의 최대 금액으로 정의`하고 규칙성을 살펴보면 세 가지이다.
  1. `dp[i]=P[i-1]` 인 경우
  2. `i의 약수 j`에 대해 `dp[i]=i//j*dp[j]` 인 경우
  3. `i=j+(i-j)`에 대해 `dp[i]=dp[j]+dp[i-j]` 인 경우
  ```python
  for i in range(2, n+1):
    dp[i]=P[i-1]
    for j in range(1, i):
        dp[i]=max(dp[i], dp[i-j]+dp[j])
        if i%j==0:
            dp[i]=max(dp[i], i//j*dp[j])
  ```

## 11727 2*n 타일링2
* 타일의 `가로 길이를 1과 2로 나눠서 생각`했다 1*2 // 2*1, 2*2
* 점화식이 먼저보이고 어떻게 나오는 지는 한참을 생각했는데 점화식은 다음 두 개 다 가능하다
  ```python
  dp[i]=dp[i-1]+dp[i-2]*2 or dp[i]=i**2-dp[i-1]
  ```
* 첫 번째 점화식이 나오는 원리는 다음과 같다.
  1. `dp[i]는 dp[i-2]에서 2칸 추가된 모양` + `dp[i-1]에서 1칸 추가된 모양`
  2. 단순히 `모양을 칸수만큼 자유롭게 추가`하면 `중복 모양이 발생`하므로 중복을 없애려면 
  3. `dp[i-1]`에서는 `좌측`에 여유칸 `1칸`만큼 추가 타일을 배치하는 수(`1x2타일 한개`) 
  4. `dp[i-2]`에서는 `좌측`에 여유칸 `2칸`만큼 추가 타일을 배치하는 수(`2x1타일 한개`, `2x2타일 1개`)
  5. 즉 `dp[i-1]+dp[i-2]*2`가 된다.
  ```python
  dp=[1]*(n+1)
  dp[1]=1
  if n>1:
      dp[2]=3
  for i in range(3, n+1):
      dp[i]=dp[i-1]+dp[i-2]*2
  ```