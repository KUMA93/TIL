import sys
sys.stdin=open("input.txt", "rt")
input=sys.stdin.readline

n=int(input()) # 1 ≤ N ≤ 30
dp=[0]*(n+1)
dp[0]=1
if n>1:
    dp[2]=3
# dp[i] dp[i-1]+1칸 dp[i-2]+2칸
# dp[1]=0
# dp[2]=3
# dp[3]=0
# dp[4]=11
# 길이n이 홀수일 때 채워야할 넓이가 n*3이 되어 홀수가 되므로 채울 수 있는 방법이 없다. dp[odd]=0
# 짝수일 때는 1*2 타일을 짝수개수로 썼을때만 넓이를 빠짐없이 채울 수 있다. 실버 문제에서 중복을 제거한 것 처럼 좌측에만 정형화된 모양(1*2타일두개 아래 2*1타일, 2*1타일아래 1*2타일두개, 2*1타일 세개)를 추가하고 새로 생기는 패턴 2개를 추가한다.
# 다음과 같은 점화식이 세워진다. dp[i]=dp[i-2]*3+2
# 인줄 알았는데 틀려서 dp[6]일 때를 생각해보니 길이를 4와 2로 나눠서 dp[4]*정형화된 모양3 만큼 경우의 수가 발생하고 길이가 4일때 발생한 특수모양 2에 나머지칸 2칸에 정형화된 모양 3개를 곱해서 2*3 그리고 6칸에서 새로 발생하는 특수패턴을 생각하면 2
# 그래서 dp[6]=dp[4]*3+2*3+2 이라고 볼수 있다.
# 8일 때는 6, 2로 나눠서 dp[6]에 정형화된 패턴 3가지를 곱해서 3*dp[6], 4, 4로 나눠서 4에서 나온 특수한 모양 2개 * dp[i-4], 2, 6으로 나눠서 6에서 나온 특수한 모양 2개*dp[i-6]
# 일반화시켜서 점화식을 세우면 dp[i]=dp[i-2]*3 + dp[i-4]*2 + ... + 2

for i in range(4, n+1):
    if i%2==0:
        dp[i]=3*dp[i-2] + 2*sum(dp[:i-2])
    else:
        dp[i]=0
print(dp[-1])